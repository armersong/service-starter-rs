use crate::read_reponse_body;
use actix_http::body::Body;
use actix_http::http::{header, StatusCode};
use actix_http::{Response, ResponseError};

error_chain! {
    foreign_links {
        Io(::std::io::Error) #[doc = "Error during IO"];
        IntParser(std::num::ParseIntError)  #[doc = "Error during integer convert"];
        Yaml(serde_yaml::Error)  #[doc = "Error during serde_yaml"];
        Json(serde_json::Error)  #[doc = "Error during serde_json"];
        Mysql(mysql_async::Error)  #[doc = "Error during mysql"];
        Redis(credis::RedisError) #[doc = "Error during redis"];
        RedisPool(redis_async_pool::deadpool::managed::PoolError<credis::RedisError>) #[doc = "Error during redis pool"];
    }
    errors {
        Network(err: String) {
            description("network error")
            display("network error: '{}'", err)
        }
        //use for service
        Database(err: String) {
            description("database error")
            display("database error: '{}'", err)
        }
        Custom(err_code: i32, err:String) {
            display("err_code '{}', reason '{}'", err_code, err)
        }
    }
}

impl From<Error> for std::io::Error {
    fn from(e: Error) -> Self {
        e.into()
    }
}

impl From<actix_http::Error> for Error {
    fn from(e: actix_http::Error) -> Self {
        let mut resp = e.as_response_error().error_response();
        let body = read_reponse_body(resp.take_body());
        Self::from_kind(ErrorKind::Custom(
            e.as_response_error().status_code().as_u16() as i32,
            String::from_utf8_lossy(body.as_slice()).to_string(),
        ))
    }
}

impl ResponseError for Error {
    fn status_code(&self) -> StatusCode {
        StatusCode::OK
    }

    /// Create response for error
    ///
    /// Internal server error is generated by default.
    fn error_response(&self) -> Response<actix_http::body::Body> {
        let mut resp = Response::new(self.status_code());
        resp.headers_mut().insert(
            header::CONTENT_TYPE,
            header::HeaderValue::from_static("application/json; charset=utf-8"),
        );
        let body = match self.kind() {
            ErrorKind::Custom(code, message) => json!({
                "result": format!("{}", code),
                "message": message,
            }),
            _ => json!({
                "result": "1",
                "message": self.description(),
            }),
        };
        resp.set_body(Body::from(serde_json::to_string(&body).unwrap_or(
            "{{ \"result\": \"500\", \"message\": \"Server Internal Error!\" }}".to_string(),
        )))
    }
}

#[macro_export]
macro_rules! request_error {
    ($expr: expr, $msg: expr) => {
        if ($expr) {
            return Err(
                $crate::Error::from($crate::ErrorKind::Custom(1, format!("{}", $msg))).into(),
            );
        }
    };
    ($expr: expr) => {
        if ($expr) {
            return Err($crate::Error::from($crate::ErrorKind::Custom(
                1,
                "Invalid request args!".to_string(),
            ))
            .into());
        }
    };
}

/// use in actix handler
#[macro_export]
macro_rules! trace_web_error {
    ($f: expr, $info: expr) => {
        $f.await.map_err(|e| {
            // error!("{} failed: {}", $info, e);
            e
        })
    };
}

pub fn map_to_custom_error(info: String) -> Error {
    Error::from(ErrorKind::Custom(crate::defines::errcode::RC_FAIL, info))
}
